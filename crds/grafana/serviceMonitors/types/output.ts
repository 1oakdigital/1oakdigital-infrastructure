// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace monitoring {
    export namespace v1 {
        /**
         * Specification of desired Service selection for target discovery by Prometheus.
         */
        export interface ServiceMonitorSpec {
            /**
             * A list of endpoints allowed as part of this ServiceMonitor.
             */
            endpoints: outputs.monitoring.v1.ServiceMonitorSpecEndpoints[];
            /**
             * Chooses the label of the Kubernetes `Endpoints`. Its value will be used for the `job`-label's value of the created metrics. 
             *  Default & fallback value: the name of the respective Kubernetes `Endpoint`.
             */
            jobLabel?: string;
            /**
             * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
             */
            labelLimit?: number;
            /**
             * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
             */
            labelNameLengthLimit?: number;
            /**
             * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
             */
            labelValueLengthLimit?: number;
            /**
             * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
             */
            namespaceSelector?: outputs.monitoring.v1.ServiceMonitorSpecNamespaceselector;
            /**
             * PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
             */
            podTargetLabels?: string[];
            /**
             * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
             */
            sampleLimit?: number;
            /**
             * Selector to select Endpoints objects.
             */
            selector: outputs.monitoring.v1.ServiceMonitorSpecSelector;
            /**
             * TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics.
             */
            targetLabels?: string[];
            /**
             * TargetLimit defines a limit on the number of scraped targets that will be accepted.
             */
            targetLimit?: number;
        }

        /**
         * Endpoint defines a scrapeable endpoint serving Prometheus metrics.
         */
        export interface ServiceMonitorSpecEndpoints {
            /**
             * Authorization section for this endpoint
             */
            authorization?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsAuthorization;
            /**
             * BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
             */
            basicAuth?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsBasicauth;
            /**
             * File to read bearer token for scraping targets.
             */
            bearerTokenFile?: string;
            /**
             * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
             */
            bearerTokenSecret?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsBearertokensecret;
            /**
             * FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
             */
            followRedirects?: boolean;
            /**
             * HonorLabels chooses the metric's labels on collisions with target labels.
             */
            honorLabels?: boolean;
            /**
             * HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
             */
            honorTimestamps?: boolean;
            /**
             * Interval at which metrics should be scraped
             */
            interval?: string;
            /**
             * MetricRelabelConfigs to apply to samples before ingestion.
             */
            metricRelabelings?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsMetricrelabelings[];
            /**
             * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
             */
            oauth2?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsOauth2;
            /**
             * Optional HTTP URL parameters
             */
            params?: {[key: string]: string[]};
            /**
             * HTTP path to scrape for metrics.
             */
            path?: string;
            /**
             * Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
             */
            port?: string;
            /**
             * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
             */
            proxyUrl?: string;
            /**
             * RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
             */
            relabelings?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsRelabelings[];
            /**
             * HTTP scheme to use for scraping.
             */
            scheme?: string;
            /**
             * Timeout after which the scrape is ended
             */
            scrapeTimeout?: string;
            /**
             * Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
             */
            targetPort?: number | string;
            /**
             * TLS configuration to use when scraping the endpoint
             */
            tlsConfig?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfig;
        }

        /**
         * Authorization section for this endpoint
         */
        export interface ServiceMonitorSpecEndpointsAuthorization {
            /**
             * The secret's key that contains the credentials of the request
             */
            credentials?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsAuthorizationCredentials;
            /**
             * Set the authentication type. Defaults to Bearer, Basic will cause an error
             */
            type?: string;
        }

        /**
         * The secret's key that contains the credentials of the request
         */
        export interface ServiceMonitorSpecEndpointsAuthorizationCredentials {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
         */
        export interface ServiceMonitorSpecEndpointsBasicauth {
            /**
             * The secret in the service monitor namespace that contains the password for authentication.
             */
            password?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsBasicauthPassword;
            /**
             * The secret in the service monitor namespace that contains the username for authentication.
             */
            username?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsBasicauthUsername;
        }

        /**
         * The secret in the service monitor namespace that contains the password for authentication.
         */
        export interface ServiceMonitorSpecEndpointsBasicauthPassword {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * The secret in the service monitor namespace that contains the username for authentication.
         */
        export interface ServiceMonitorSpecEndpointsBasicauthUsername {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
         */
        export interface ServiceMonitorSpecEndpointsBearertokensecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
         */
        export interface ServiceMonitorSpecEndpointsMetricrelabelings {
            /**
             * Action to perform based on regex matching. Default is 'replace'
             */
            action?: string;
            /**
             * Modulus to take of the hash of the source label values.
             */
            modulus?: number;
            /**
             * Regular expression against which the extracted value is matched. Default is '(.*)'
             */
            regex?: string;
            /**
             * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
             */
            replacement?: string;
            /**
             * Separator placed between concatenated source label values. default is ';'.
             */
            separator?: string;
            /**
             * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
             */
            sourceLabels?: string[];
            /**
             * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
             */
            targetLabel?: string;
        }
        /**
         * serviceMonitorSpecEndpointsMetricrelabelingsProvideDefaults sets the appropriate defaults for ServiceMonitorSpecEndpointsMetricrelabelings
         */
        export function serviceMonitorSpecEndpointsMetricrelabelingsProvideDefaults(val: ServiceMonitorSpecEndpointsMetricrelabelings): ServiceMonitorSpecEndpointsMetricrelabelings {
            return {
                ...val,
                action: (val.action) ?? "replace",
            };
        }

        /**
         * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
         */
        export interface ServiceMonitorSpecEndpointsOauth2 {
            /**
             * The secret or configmap containing the OAuth2 client id
             */
            clientId: outputs.monitoring.v1.ServiceMonitorSpecEndpointsOauth2Clientid;
            /**
             * The secret containing the OAuth2 client secret
             */
            clientSecret: outputs.monitoring.v1.ServiceMonitorSpecEndpointsOauth2Clientsecret;
            /**
             * Parameters to append to the token URL
             */
            endpointParams?: {[key: string]: string};
            /**
             * OAuth2 scopes used for the token request
             */
            scopes?: string[];
            /**
             * The URL to fetch the token from
             */
            tokenUrl: string;
        }

        /**
         * The secret or configmap containing the OAuth2 client id
         */
        export interface ServiceMonitorSpecEndpointsOauth2Clientid {
            /**
             * ConfigMap containing data to use for the targets.
             */
            configMap?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsOauth2ClientidConfigmap;
            /**
             * Secret containing data to use for the targets.
             */
            secret?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsOauth2ClientidSecret;
        }

        /**
         * ConfigMap containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsOauth2ClientidConfigmap {
            /**
             * The key to select.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Secret containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsOauth2ClientidSecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * The secret containing the OAuth2 client secret
         */
        export interface ServiceMonitorSpecEndpointsOauth2Clientsecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
         */
        export interface ServiceMonitorSpecEndpointsRelabelings {
            /**
             * Action to perform based on regex matching. Default is 'replace'
             */
            action?: string;
            /**
             * Modulus to take of the hash of the source label values.
             */
            modulus?: number;
            /**
             * Regular expression against which the extracted value is matched. Default is '(.*)'
             */
            regex?: string;
            /**
             * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
             */
            replacement?: string;
            /**
             * Separator placed between concatenated source label values. default is ';'.
             */
            separator?: string;
            /**
             * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
             */
            sourceLabels?: string[];
            /**
             * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
             */
            targetLabel?: string;
        }
        /**
         * serviceMonitorSpecEndpointsRelabelingsProvideDefaults sets the appropriate defaults for ServiceMonitorSpecEndpointsRelabelings
         */
        export function serviceMonitorSpecEndpointsRelabelingsProvideDefaults(val: ServiceMonitorSpecEndpointsRelabelings): ServiceMonitorSpecEndpointsRelabelings {
            return {
                ...val,
                action: (val.action) ?? "replace",
            };
        }

        /**
         * TLS configuration to use when scraping the endpoint
         */
        export interface ServiceMonitorSpecEndpointsTlsconfig {
            /**
             * Struct containing the CA cert to use for the targets.
             */
            ca?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCa;
            /**
             * Path to the CA cert in the Prometheus container to use for the targets.
             */
            caFile?: string;
            /**
             * Struct containing the client cert file for the targets.
             */
            cert?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCert;
            /**
             * Path to the client cert file in the Prometheus container for the targets.
             */
            certFile?: string;
            /**
             * Disable target certificate validation.
             */
            insecureSkipVerify?: boolean;
            /**
             * Path to the client key file in the Prometheus container for the targets.
             */
            keyFile?: string;
            /**
             * Secret containing the client key file for the targets.
             */
            keySecret?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigKeysecret;
            /**
             * Used to verify the hostname for the targets.
             */
            serverName?: string;
        }

        /**
         * Struct containing the CA cert to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCa {
            /**
             * ConfigMap containing data to use for the targets.
             */
            configMap?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCaConfigmap;
            /**
             * Secret containing data to use for the targets.
             */
            secret?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCaSecret;
        }

        /**
         * ConfigMap containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCaConfigmap {
            /**
             * The key to select.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Secret containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCaSecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Struct containing the client cert file for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCert {
            /**
             * ConfigMap containing data to use for the targets.
             */
            configMap?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCertConfigmap;
            /**
             * Secret containing data to use for the targets.
             */
            secret?: outputs.monitoring.v1.ServiceMonitorSpecEndpointsTlsconfigCertSecret;
        }

        /**
         * ConfigMap containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCertConfigmap {
            /**
             * The key to select.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Secret containing data to use for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigCertSecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Secret containing the client key file for the targets.
         */
        export interface ServiceMonitorSpecEndpointsTlsconfigKeysecret {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: boolean;
        }

        /**
         * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
         */
        export interface ServiceMonitorSpecNamespaceselector {
            /**
             * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
             */
            any?: boolean;
            /**
             * List of namespace names to select from.
             */
            matchNames?: string[];
        }

        /**
         * Selector to select Endpoints objects.
         */
        export interface ServiceMonitorSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.monitoring.v1.ServiceMonitorSpecSelectorMatchexpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ServiceMonitorSpecSelectorMatchexpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

    }
}
